---
title: 深入理解 KMP 算法
tag: algorithms
---
KMP 是一个很厉害的算法. 粗略地说, 它利用了字符串的一个性质: 字符串串的尾部有可能与自己的首部相匹配. 比如说字符串 `abcab`, 它的尾部有两个字符可以与自己的首部相匹配:

```
   abcab
   ||
abcab
```

用形式化的语言描述: 对于一个字符串 `t`, 存在一个最大的数 `0 <= m < len(t)`, 使得 `t[:m] == t[-m:]` 成立. 我们称 `m` 为**最大首尾匹配长度**. 注意 `m` 必须小于 `t` 的长度, 不然没有意义 -- 任何字符串总是与自身相等.

KMP 首先会为模式串的所有前缀求得最大首尾匹配长度, 存储在数组 `pi` 中. 前缀 `t[:i]` 的最大首尾匹配长度为 `pi[i-1]`. 例如字符串 `p = "abcab"` 的 `pi` 数组为 `[0, 0, 0, 1, 2]`, 因为:

- `p[:1] = "a"`, 最大首尾匹配长度为 0, `pi[0] = 0`
- `p[:2] = "ab"`, 最大首尾匹配长度为 0, `pi[1] = 0`
- `p[:3] = "abc"`, 最大首尾匹配长度为 0, `pi[2] = 0`
- `p[:4] = "abca"`, 最大首尾匹配长度为 1, `pi[0] = 1`, 因为有
    ```
       abca
       |
    abca
    ```
- `p[:5] = "abcab"`, 最大首尾匹配长度为 2, `pi[0] = 2`, 因为
    ```
       abcab
       ||
    abcab
    ```

我们先不管 KMP 是怎样求 `pi` 数组的, 先看看 KMP 是怎样利用 `pi` 数组做匹配的.

假设字符串 `s` 与模式串 `t` 匹配. 我们从第 0 个字符开始匹配, 接着是第 1 个, 第 2 个, 一直到第 k 个字符, 都匹配成功了; 然而第 k + 1 个字符匹配失败了.

匹配失败了, 那怎么办呢? 重点来了. 第 0 至 k 个字符匹配成功了, `pi` 数组告诉我们, 这段子串的后 `pi[k]` 个字符正好等于它的前 `pi[k]` 个字符.

因为第 0 至 k 个字符也就是 `t[:k+1]`, 它的最大首尾匹配长度为 `pi[k]`.
