---
title: 谈谈无锁队列
tag: c++
---
前一篇文章中我们讨论了 C++ 中原子变量的内存顺序. 现在我们来看看原子变量和内存顺序的应用 -- 无锁队列.

## 何谓无锁

为了实现一个线程安全的数据结构, 最简单的方法就是加锁. 对于队列来说, 应该对入队和出队操作加锁.

```c++
template <typename T>
void queue::push(const T &val) {
    std::lock_guard<std::mutex> guard(m_lock);
    auto node = new node(val);
    ...
}

template <typename T>
T queue::pop() {
    std::lock_guard<std::mutex> guard(m_lock);
    ... 
}
```

这样的队列的问题是, 同一时间只能有一个线程执行入队和出队操作, 这样队列的操作实际是串行化的. 如果有多个线程同时访问同一个队列, 这个队列可能会成为并发的瓶颈. 为了解决这个问题, 在一些场景下我们可以考虑使用无锁队列.

无锁数据接口可以分为三类:

1. nonblocking 结构
    - 使用自旋锁而不是互斥量, 不会出现上下文切换.
    - 不能算是无锁 (lock-free), 它并不允许并发访问, 同样存在操作串行化的问题.
2. lock-free 结构
    - 精心设计的操作, 通过 CAS (compare and swap) 原子操作实现并发访问. 多个线程可以同时访问.
    - 存在类似自旋锁的循环, 需要在循环中检查和等待.
3. wait-free 结构
    - 不存在类似自旋锁的循环, 操作只需要执行确定数量的指令.

下面我们介绍几种简单的无锁队列的实现.

## 单写单读的队列

