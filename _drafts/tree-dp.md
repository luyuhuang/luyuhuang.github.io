---
title: "树形动态规划: 如何处理子节点依赖父节点的问题"
tag: [algorithms, leetcode]
aside: false
---
动态规划规划是一种很常见的算法. 它的思路基本上是将大问题转化成小问题, 大问题依赖小问题的结果. 常见的动态规划有一维动态规划, x = N 的问题可能依赖 x = N - 1 的问题

![1d](/assets/images/tree-dp_1.svg)

这样只要我们知道 x = 0 的问题的解, 就能逐步推出 x = N 的问题的解. 或者有二维动态规划, x = N, y = M 的问题可能依赖 x = N - 1, y = M 和 x = N, y = M - 1 的问题.

![2d](/assets/images/tree-dp_2.svg)

这样我们也可以从 x = 0, y = 0 的问题的解逐步推出 x = N, Y = M 的问题的解. 但有一类特殊的动态规划, 子问题之间的依赖关系是网状的

![tree](/assets/images/tree-dp_3.svg)

如果把子问题看作节点, 依赖关系看作边, 整个问题就可以看作一个无向图. 如果这个图没有环路, 那么它也可以看作一颗树. 如何解决树形动态规划问题? 本文我们来探讨它.

### 最小高度树

问题来自 [LeetCode 310 题](https://leetcode-cn.com/problems/minimum-height-trees/). 给定一个无向无环图, 将其中的一个节点视为根节点, 那么它也可以看作一棵树. 求选取哪个节点作为根节点能让这棵树高度最小. 需要返回所有的解. 例如下图所示的树, 选择 3 号或者 4 号节点能让树的高度最小, 因此返回 `[3, 4]`.

![problem](/assets/images/tree-dp_4.jpeg){:width="500"}

最笨的办法就是, 对于每个节点, 使用 BFS 或者 DFS 计算出离它最远的节点的距离, 便是将它视为根节点时树的高度; 最后返回高度最小的节点. 如果图中有 $N$ 个节点, 这种做法的时间复杂度就是 $\mathrm{O}(N)$. 有没有更好的方法呢?

令将节点 $i$ 视为根节点时树的高度为 $H(i)$. 假设与节点 $i$ 相邻的节点有 $i_1, i_2, ..., i_k$, 不难发现节点 $i$ 作为根节点时树的高度取决于与其相邻的节点作为根节点是树的高度. 也就是

$$
H(i) = \max(H(i_1), H(i_2), ..., H(i_k)) + 1 \tag 1
$$

但是问题是, 当一个节点依赖它的相邻节点时, 相邻节点也在依赖它. 如何解决这个互相依赖的问题呢?

![depends](/assets/images/tree-dp_4.svg)

图的结构比较混乱, 我们不妨取其中任意一个节点作为根节点, 将图视为一棵树. 这样对于节点 $i$, 总有一个父节点 $i_p$ 和若干个子节点 $i_{c1}, i_{c2}, ..., i_{ck}$. $H(i)$ 取决于其子节点和父节点, 也就是

$$
H(i) = \max(H(i_p), H(i_{c1}), H(i_{c2}), ..., H(i_{ck})) + 1 \tag 2
$$

(2) 式不过是 (1) 式换种写法而已. 不过现在我们有更清晰的思路了: 我们可以分两步走:

1. 从根节点开始, 递归地求每个节点 $i$ 的 $\max(H(i_{c1}), H(i_{c2}), ..., H(i_{ck}))$.
2. 再次从根节点开始, 递归的求出每个节点 $i$ 的 $H(i_p)$.
